/**
 * Generates a bearer token authentication wrapper for MCP worker bundles.
 *
 * This wrapper sits in front of the actual MCP worker and validates bearer tokens
 * using two methods (matching the reference implementation pattern):
 *   1. Token in URL path: /mcp/t/{token}
 *   2. Token in Authorization header: Bearer {token}
 *
 * Based on the reference implementation from zotero-assistant-mcp-remote.
 */

/**
 * Generate the bearer token wrapper module code.
 *
 * @param durableObjectClassName - The DO class to re-export (e.g., "ZoteroMCP")
 */
export function generateBearerTokenWrapper(
    durableObjectClassName: string
): string {
    return `
// ─── Bearer Token Authentication Wrapper ───
// Auto-generated by mcp-deploy. Do not edit.

import OriginalWorker from './original.mjs';
export { ${durableObjectClassName} } from './original.mjs';

// ─── Worker fetch handler ───

export default {
  fetch(request, env, ctx) {
    const url = new URL(request.url);

    // Health check — no secrets exposed
    if (url.pathname === '/') {
      return new Response(
        JSON.stringify({
          name: 'mcp-server',
          status: 'ok',
        }),
        { headers: { 'content-type': 'application/json' } }
      );
    }

    // -----------------------------------------------------------------------
    // Authentication — supports two methods:
    //   1. URL token:    /mcp/t/{token}  (for Claude Desktop UI connector)
    //   2. Bearer header: Authorization: Bearer {token}  (for API/CLI)
    // -----------------------------------------------------------------------

    // Method 1: Token in URL path — /mcp/t/{token} or /mcp/t/{token}/...
    const tokenMatch = url.pathname.match(/^\\/mcp\\/t\\/([^/]+)(\\/.*)?$/);
    if (tokenMatch) {
      const urlToken = tokenMatch[1];
      if (!env.BEARER_TOKEN || urlToken !== env.BEARER_TOKEN) {
        return new Response(
          JSON.stringify({ error: 'Unauthorized' }),
          { status: 401, headers: { 'content-type': 'application/json' } }
        );
      }
      // Rewrite URL: strip /t/{token} so the MCP handler sees /mcp
      // Add Authorization header so the original worker's auth also passes
      const rewrittenPath = '/mcp' + (tokenMatch[2] || '');
      const rewrittenUrl = new URL(rewrittenPath, url.origin);
      rewrittenUrl.search = url.search;
      const rewrittenHeaders = new Headers(request.headers);
      rewrittenHeaders.set('Authorization', \`Bearer \${env.BEARER_TOKEN}\`);
      const rewrittenRequest = new Request(rewrittenUrl.toString(), {
        method: request.method,
        headers: rewrittenHeaders,
        body: request.body,
        duplex: 'half',
      });
      return OriginalWorker.fetch(rewrittenRequest, env, ctx);
    }

    // Method 2: Bearer header on /mcp
    if (url.pathname.startsWith('/mcp')) {
      const auth = request.headers.get('Authorization');
      if (!env.BEARER_TOKEN || !auth || auth !== \`Bearer \${env.BEARER_TOKEN}\`) {
        return new Response(
          JSON.stringify({ error: 'Unauthorized' }),
          {
            status: 401,
            headers: {
              'content-type': 'application/json',
              'WWW-Authenticate': 'Bearer',
            },
          }
        );
      }
    }

    return OriginalWorker.fetch(request, env, ctx);
  },
};
`.trim();
}
