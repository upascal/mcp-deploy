/**
 * Generates an OAuth wrapper module that sits in front of MCP worker bundles.
 *
 * At deploy time, we upload TWO modules to Cloudflare:
 *   1. `original.mjs` - The actual MCP worker code from the GitHub release
 *   2. `index.mjs`    - This generated wrapper (the main_module entry point)
 *
 * The wrapper is a COMPLETE OAuth 2.1 Authorization Server and resource proxy:
 *   - Serves `/.well-known/oauth-authorization-server` (RFC 8414) with server metadata.
 *   - Serves `/.well-known/oauth-protected-resource` (RFC 9728) for resource discovery.
 *   - Handles `/oauth/authorize` (GET) — serves a consent page with password gate.
 *   - Handles `/oauth/approve` (POST) — validates password, generates auth code.
 *   - Handles `/oauth/token` (POST) — exchanges code for JWT (PKCE + client auth).
 *   - Handles `/oauth/register` (POST) — dynamic client registration (DCR).
 *   - Validates OAuth JWT access tokens (HMAC-SHA256) on MCP requests.
 *   - Re-exports Durable Object classes from the original worker.
 *
 * Storage: Uses Cloudflare KV (`env.OAUTH_KV`) for OAuth clients and auth codes.
 * Secrets: `env.OAUTH_JWT_SECRET` for JWT signing, `env.OAUTH_PASSWORD` for consent.
 */

/**
 * Generate the OAuth wrapper module code.
 *
 * @param durableObjectClassName - The DO class to re-export (e.g., "ZoteroMCP")
 */
export function generateOAuthWrapper(
  durableObjectClassName: string
): string {
  // The wrapper is generated as a string because it runs in Cloudflare Workers,
  // not in Node.js. It uses only Web Crypto APIs and Cloudflare KV.
  return `
// ─── OAuth 2.1 Authorization Server + MCP Worker Wrapper ───
// Auto-generated by mcp-deploy. Do not edit.

import OriginalWorker from './original.mjs';
export { ${durableObjectClassName} } from './original.mjs';

// ─── Crypto Helpers (Web Crypto API) ───

function base64urlEncode(input) {
  const bytes = input instanceof Uint8Array ? input : new Uint8Array(input);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');
}

function base64urlDecode(str) {
  str = str.replace(/-/g, '+').replace(/_/g, '/');
  while (str.length % 4) str += '=';
  const binary = atob(str);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes;
}

function randomHex(bytes) {
  const arr = new Uint8Array(bytes);
  crypto.getRandomValues(arr);
  return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function sha256(input) {
  const data = new TextEncoder().encode(input);
  return new Uint8Array(await crypto.subtle.digest('SHA-256', data));
}

// ─── JWT (HMAC-SHA256) ───

async function signJWT(payload, secret) {
  const header = { alg: 'HS256', typ: 'JWT' };
  const headerB64 = base64urlEncode(new TextEncoder().encode(JSON.stringify(header)));
  const payloadB64 = base64urlEncode(new TextEncoder().encode(JSON.stringify(payload)));
  const signingInput = headerB64 + '.' + payloadB64;

  const keyData = new TextEncoder().encode(secret);
  const key = await crypto.subtle.importKey(
    'raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']
  );
  const signature = await crypto.subtle.sign('HMAC', key, new TextEncoder().encode(signingInput));
  return signingInput + '.' + base64urlEncode(signature);
}

async function verifyJWT(token, secret, expectedAudience) {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const [headerB64, payloadB64, signatureB64] = parts;

    const keyData = new TextEncoder().encode(secret);
    const key = await crypto.subtle.importKey(
      'raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['verify']
    );

    const data = new TextEncoder().encode(headerB64 + '.' + payloadB64);
    const signature = base64urlDecode(signatureB64);
    const valid = await crypto.subtle.verify('HMAC', key, signature, data);
    if (!valid) return null;

    const payload = JSON.parse(new TextDecoder().decode(base64urlDecode(payloadB64)));
    const now = Math.floor(Date.now() / 1000);

    if (payload.exp && payload.exp < now) return null;
    if (expectedAudience && payload.aud && payload.aud !== expectedAudience) return null;

    return payload;
  } catch {
    return null;
  }
}

// ─── OAuth Helpers ───

const ACCESS_TOKEN_TTL = 3600; // 1 hour
const AUTH_CODE_TTL = 600; // 10 minutes

function jsonResponse(data, status = 200, extraHeaders = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 'no-store',
      'Access-Control-Allow-Origin': '*',
      ...extraHeaders
    }
  });
}

function corsPreflight() {
  return new Response(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      'Access-Control-Max-Age': '86400'
    }
  });
}

function encodeKey(str) {
  return base64urlEncode(new TextEncoder().encode(str));
}

function keyPrefix(origin) {
  return 'oauth:' + encodeKey(origin);
}

function isLocalhostUri(uri) {
  try {
    const u = new URL(uri);
    return u.hostname === 'localhost' || u.hostname === '127.0.0.1';
  } catch { return false; }
}

async function getKvJson(env, key) {
  if (!env.OAUTH_KV) return null;
  const raw = await env.OAUTH_KV.get(key);
  return raw ? JSON.parse(raw) : null;
}

async function putKvJson(env, key, value, ttl) {
  if (!env.OAUTH_KV) return;
  const options = ttl ? { expirationTtl: ttl } : undefined;
  await env.OAUTH_KV.put(key, JSON.stringify(value), options);
}

async function deleteKv(env, key) {
  if (!env.OAUTH_KV) return;
  await env.OAUTH_KV.delete(key);
}

async function validateRedirectUri(redirectUri, client) {
  if (isLocalhostUri(redirectUri)) return true;
  if (client.redirect_uris) {
    for (const registered of client.redirect_uris) {
      try {
        if (new URL(registered).origin === new URL(redirectUri).origin) return true;
      } catch {
        if (registered === redirectUri) return true;
      }
    }
  }
  return false;
}

function constantTimeEqual(a, b) {
  const len = Math.max(a.length, b.length);
  let result = a.length ^ b.length;
  for (let i = 0; i < len; i++) {
    const aChar = a.charCodeAt(i) || 0;
    const bChar = b.charCodeAt(i) || 0;
    result |= aChar ^ bChar;
  }
  return result === 0;
}

// ─── Consent Page HTML ───

function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function safeConsentParams(searchParams) {
  const raw = {};
  for (const key of ['client_id', 'redirect_uri', 'response_type', 'code_challenge', 'code_challenge_method', 'scope', 'state', 'resource']) {
    raw[key] = escapeHtml(searchParams.get(key) || '');
  }
  return raw;
}

function consentPageHTML(params, resourceName, errorMsg, requirePassword) {
  const errorBlock = errorMsg
    ? '<div class="error">' + errorMsg + '</div>'
    : '';
  const passwordBlock = requirePassword
    ? '\\n      <div class="field">' +
      '<label>Password</label>' +
      '<input type="password" name="password" autocomplete="current-password" required />' +
      '</div>'
    : '';

  return '<!DOCTYPE html>' +
    '\\n<html lang=\"en\">' +
    '\\n<head>' +
    '\\n  <meta charset=\"UTF-8\">' +
    '\\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">' +
    '\\n  <title>Authorize MCP Access</title>' +
    '\\n  <style>' +
    '\\n    * { margin: 0; padding: 0; box-sizing: border-box; }' +
    '\\n    body {' +
    '\\n      font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;' +
    '\\n      background: #0a0a0a; color: #e5e5e5;' +
    '\\n      display: flex; justify-content: center; align-items: center;' +
    '\\n      min-height: 100vh; padding: 20px;' +
    '\\n    }' +
    '\\n    .card {' +
    '\\n      background: #171717; border: 1px solid #262626; border-radius: 12px;' +
    '\\n      padding: 32px; max-width: 440px; width: 100%;' +
    '\\n    }' +
    '\\n    h1 { font-size: 20px; font-weight: 600; margin-bottom: 8px; color: #fafafa; }' +
    '\\n    .subtitle { color: #a3a3a3; font-size: 14px; margin-bottom: 16px; }' +
    '\\n    .resource {' +
    '\\n      background: #262626; border-radius: 8px; padding: 12px 16px;' +
    '\\n      margin-bottom: 16px; font-family: monospace; font-size: 13px;' +
    '\\n      color: #60a5fa; word-break: break-all;' +
    '\\n    }' +
    '\\n    .scope-label { font-size: 13px; color: #a3a3a3; margin-bottom: 8px; }' +
    '\\n    .scope {' +
    '\\n      background: #1e293b; border: 1px solid #334155; border-radius: 6px;' +
    '\\n      padding: 8px 12px; font-size: 13px; color: #93c5fd; margin-bottom: 16px;' +
    '\\n    }' +
    '\\n    .error {' +
    '\\n      background: #3b0a0a; border: 1px solid #7f1d1d; color: #fca5a5;' +
    '\\n      padding: 10px 12px; border-radius: 8px; font-size: 13px; margin-bottom: 16px;' +
    '\\n    }' +
    '\\n    .field { margin-bottom: 16px; }' +
    '\\n    .field label { display: block; font-size: 12px; color: #a3a3a3; margin-bottom: 6px; }' +
    '\\n    .field input {' +
    '\\n      width: 100%; padding: 10px 12px; border-radius: 8px;' +
    '\\n      border: 1px solid #404040; background: #0f0f0f; color: #f5f5f5;' +
    '\\n    }' +
    '\\n    .buttons { display: flex; gap: 12px; }' +
    '\\n    button {' +
    '\\n      flex: 1; padding: 10px 20px; border-radius: 8px; font-size: 14px;' +
    '\\n      font-weight: 500; cursor: pointer; border: none; transition: opacity 0.15s;' +
    '\\n    }' +
    '\\n    button:hover { opacity: 0.85; }' +
    '\\n    .btn-approve { background: #2563eb; color: white; }' +
    '\\n    .btn-deny { background: #262626; color: #a3a3a3; border: 1px solid #404040; }' +
    '\\n  </style>' +
    '\\n</head>' +
    '\\n<body>' +
    '\\n  <div class=\"card\">' +
    '\\n    <h1>Authorize MCP Access</h1>' +
    '\\n    <p class=\"subtitle\">An application wants to access this MCP server.</p>' +
    '\\n    <div class=\"resource\">' + resourceName + '</div>' +
    '\\n    ' + errorBlock +
    '\\n    <div class=\"scope-label\">Requested permissions:</div>' +
    '\\n    <div class=\"scope\">Access MCP tools and resources</div>' +
    '\\n    <form method=\"POST\" action=\"/oauth/approve\" class=\"auth-form\">' +
    '\\n      <input type=\"hidden\" name=\"client_id\" value=\"' + (params.client_id || '') + '\">' +
    '\\n      <input type=\"hidden\" name=\"redirect_uri\" value=\"' + (params.redirect_uri || '') + '\">' +
    '\\n      <input type=\"hidden\" name=\"response_type\" value=\"' + (params.response_type || '') + '\">' +
    '\\n      <input type=\"hidden\" name=\"code_challenge\" value=\"' + (params.code_challenge || '') + '\">' +
    '\\n      <input type=\"hidden\" name=\"code_challenge_method\" value=\"' + (params.code_challenge_method || '') + '\">' +
    '\\n      <input type=\"hidden\" name=\"scope\" value=\"' + (params.scope || 'mcp') + '\">' +
    '\\n      <input type=\"hidden\" name=\"state\" value=\"' + (params.state || '') + '\">' +
    '\\n      <input type=\"hidden\" name=\"resource\" value=\"' + (params.resource || '') + '\">' +
    passwordBlock +
    '\\n      <div class=\"buttons\">' +
    '\\n        <button type=\"submit\" class=\"btn-approve\">Authorize</button>' +
    '\\n        <button type=\"button\" class=\"btn-deny\" onclick=\"denyAccess()\">Deny</button>' +
    '\\n      </div>' +
    '\\n    </form>' +
    '\\n  </div>' +
    '\\n  <script>' +
    '\\n    function denyAccess() {' +
    '\\n      const redirect = \"' + (params.redirect_uri || '') + '\";' +
    '\\n      const state = \"' + (params.state || '') + '\";' +
    '\\n      if (redirect) {' +
    '\\n        const u = new URL(redirect);' +
    '\\n        u.searchParams.set(\"error\", \"access_denied\");' +
    '\\n        if (state) u.searchParams.set(\"state\", state);' +
    '\\n        window.location.href = u.toString();' +
    '\\n      }' +
    '\\n    }' +
    '\\n  </script>' +
    '\\n</body>' +
    '\\n</html>';
}

// ─── Main Worker ───

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const origin = url.origin;
    const prefix = keyPrefix(origin);

    // Health check — no secrets exposed
    if (url.pathname === '/') {
      return new Response(
        JSON.stringify({ name: 'mcp-server', status: 'ok' }),
        { headers: { 'content-type': 'application/json' } }
      );
    }

    // ── OAuth Discovery Endpoints ──

    // RFC 8414: OAuth Authorization Server Metadata
    if (url.pathname === '/.well-known/oauth-authorization-server') {
      return jsonResponse({
        issuer: origin,
        authorization_endpoint: origin + '/oauth/authorize',
        token_endpoint: origin + '/oauth/token',
        registration_endpoint: origin + '/oauth/register',
        response_types_supported: ['code'],
        grant_types_supported: ['authorization_code'],
        code_challenge_methods_supported: ['S256'],
        token_endpoint_auth_methods_supported: ['client_secret_post', 'none'],
        scopes_supported: ['mcp']
      }, 200, { 'Cache-Control': 'public, max-age=3600' });
    }

    // RFC 9728: OAuth Protected Resource Metadata
    if (url.pathname === '/.well-known/oauth-protected-resource') {
      return jsonResponse({
        resource: origin,
        authorization_servers: [origin],
        bearer_methods_supported: ['header']
      }, 200, { 'Cache-Control': 'public, max-age=3600' });
    }

    // ── OAuth Authorization Endpoint ──

    if (url.pathname === '/oauth/authorize' && request.method === 'GET') {
      const raw = {
        client_id: url.searchParams.get('client_id') || '',
        redirect_uri: url.searchParams.get('redirect_uri') || '',
        response_type: url.searchParams.get('response_type') || '',
        code_challenge: url.searchParams.get('code_challenge') || '',
        code_challenge_method: url.searchParams.get('code_challenge_method') || '',
        scope: url.searchParams.get('scope') || 'mcp',
        state: url.searchParams.get('state') || '',
        resource: url.searchParams.get('resource') || ''
      };

      if (!raw.client_id || !raw.redirect_uri || !raw.code_challenge) {
        return new Response('Missing required OAuth parameters (client_id, redirect_uri, code_challenge)', {
          status: 400, headers: { 'Content-Type': 'text/plain' }
        });
      }
      if (raw.response_type && raw.response_type !== 'code') {
        return new Response('Unsupported response_type', { status: 400 });
      }
      if (raw.code_challenge_method && raw.code_challenge_method !== 'S256') {
        return new Response('Only S256 code_challenge_method is supported', { status: 400 });
      }

      if (raw.resource) {
        try {
          if (new URL(raw.resource).origin !== origin) {
            return new Response('Invalid resource for this authorization server', { status: 400 });
          }
        } catch {
          return new Response('Invalid resource URL', { status: 400 });
        }
      }

      if (!env.OAUTH_KV) {
        return new Response('OAuth KV not configured', { status: 500 });
      }

      const client = await getKvJson(env, prefix + ':client:' + raw.client_id);
      if (!client) {
        return new Response('Unknown client_id', { status: 400 });
      }

      if (!(await validateRedirectUri(raw.redirect_uri, client))) {
        return new Response('Invalid redirect_uri', { status: 400 });
      }

      const params = safeConsentParams(url.searchParams);
      const hostParts = url.hostname.split('.');
      const resourceName = escapeHtml(hostParts[0] || url.hostname);
      const requirePassword = Boolean(env.OAUTH_PASSWORD);

      return new Response(consentPageHTML(params, resourceName, '', requirePassword), {
        headers: { 'Content-Type': 'text/html; charset=utf-8' }
      });
    }

    // ── OAuth Approve (consent form POST) ──

    if (url.pathname === '/oauth/approve' && request.method === 'POST') {
      try {
        const formData = await request.formData();
        const raw = {
          client_id: String(formData.get('client_id') || ''),
          redirect_uri: String(formData.get('redirect_uri') || ''),
          response_type: String(formData.get('response_type') || ''),
          code_challenge: String(formData.get('code_challenge') || ''),
          code_challenge_method: String(formData.get('code_challenge_method') || ''),
          scope: String(formData.get('scope') || 'mcp'),
          state: String(formData.get('state') || ''),
          resource: String(formData.get('resource') || ''),
          password: String(formData.get('password') || '')
        };

        if (!raw.client_id || !raw.redirect_uri || !raw.code_challenge) {
          return new Response('Missing required parameters', { status: 400 });
        }
        if (raw.response_type && raw.response_type !== 'code') {
          return new Response('Unsupported response_type', { status: 400 });
        }
        if (raw.code_challenge_method && raw.code_challenge_method !== 'S256') {
          return new Response('Only S256 code_challenge_method is supported', { status: 400 });
        }

        let resourceOrigin = origin;
        if (raw.resource) {
          try {
            resourceOrigin = new URL(raw.resource).origin;
            if (resourceOrigin !== origin) {
              return new Response('Invalid resource for this authorization server', { status: 400 });
            }
          } catch {
            return new Response('Invalid resource URL', { status: 400 });
          }
        }

        if (!env.OAUTH_KV) {
          return new Response('OAuth KV not configured', { status: 500 });
        }

        const client = await getKvJson(env, prefix + ':client:' + raw.client_id);
        if (!client) {
          return new Response('Unknown client_id', { status: 400 });
        }

        if (!(await validateRedirectUri(raw.redirect_uri, client))) {
          return new Response('Invalid redirect_uri', { status: 400 });
        }

        const requirePassword = Boolean(env.OAUTH_PASSWORD);
        if (requirePassword) {
          const expected = String(env.OAUTH_PASSWORD || '');
          if (!raw.password || !constantTimeEqual(raw.password, expected)) {
            const params = safeConsentParams(new URLSearchParams({
              client_id: raw.client_id,
              redirect_uri: raw.redirect_uri,
              response_type: raw.response_type,
              code_challenge: raw.code_challenge,
              code_challenge_method: raw.code_challenge_method,
              scope: raw.scope,
              state: raw.state,
              resource: raw.resource
            }));
            const hostParts = url.hostname.split('.');
            const resourceName = escapeHtml(hostParts[0] || url.hostname);
            return new Response(consentPageHTML(params, resourceName, 'Invalid password', true), {
              status: 401,
              headers: { 'Content-Type': 'text/html; charset=utf-8' }
            });
          }
        }

        const code = randomHex(32);
        const authCode = {
          code,
          clientId: raw.client_id,
          redirectUri: raw.redirect_uri,
          codeChallenge: raw.code_challenge,
          codeChallengeMethod: raw.code_challenge_method || 'S256',
          scope: raw.scope || 'mcp',
          resource: resourceOrigin,
          createdAt: Math.floor(Date.now() / 1000)
        };

        await putKvJson(env, prefix + ':code:' + code, authCode, AUTH_CODE_TTL);

        const redirectUrl = new URL(raw.redirect_uri);
        redirectUrl.searchParams.set('code', code);
        if (raw.state) redirectUrl.searchParams.set('state', raw.state);

        return new Response(null, {
          status: 302,
          headers: { 'Location': redirectUrl.toString() }
        });
      } catch (err) {
        return new Response('Internal error: ' + err.message, { status: 500 });
      }
    }

    // ── OAuth Token Endpoint ──

    if (url.pathname === '/oauth/token' && request.method === 'OPTIONS') {
      return corsPreflight();
    }

    if (url.pathname === '/oauth/token' && request.method === 'POST') {
      try {
        let params = {};
        const contentType = request.headers.get('Content-Type') || '';
        if (contentType.includes('application/x-www-form-urlencoded')) {
          const formData = await request.formData();
          for (const [key, value] of formData.entries()) {
            params[key] = value;
          }
        } else if (contentType.includes('application/json')) {
          params = await request.json();
        } else {
          try {
            const text = await request.text();
            const searchParams = new URLSearchParams(text);
            for (const [key, value] of searchParams.entries()) {
              params[key] = value;
            }
          } catch {
            return jsonResponse({ error: 'invalid_request', error_description: 'Unable to parse request body' }, 400);
          }
        }

        const grant_type = params.grant_type || '';
        const code = params.code || '';
        const redirect_uri = params.redirect_uri || '';
        const client_id = params.client_id || '';
        const client_secret = params.client_secret || '';
        const code_verifier = params.code_verifier || '';

        if (grant_type !== 'authorization_code') {
          return jsonResponse({ error: 'unsupported_grant_type' }, 400);
        }

        if (!code || !client_id || !code_verifier) {
          return jsonResponse({ error: 'invalid_request', error_description: 'Missing required parameters' }, 400);
        }

        if (!env.OAUTH_KV) {
          return jsonResponse({ error: 'server_error', error_description: 'OAuth KV not configured' }, 500);
        }

        const client = await getKvJson(env, prefix + ':client:' + client_id);
        if (!client) {
          return jsonResponse({ error: 'invalid_client', error_description: 'Unknown client_id' }, 401);
        }

        if (client.token_endpoint_auth_method !== 'none') {
          if (!client.client_secret || client.client_secret !== client_secret) {
            return jsonResponse({ error: 'invalid_client', error_description: 'Invalid client_secret' }, 401);
          }
        }

        const authCode = await getKvJson(env, prefix + ':code:' + code);
        if (!authCode) {
          return jsonResponse({ error: 'invalid_grant', error_description: 'Authorization code not found or expired' }, 400);
        }
        await deleteKv(env, prefix + ':code:' + code);

        if (authCode.clientId !== client_id) {
          return jsonResponse({ error: 'invalid_grant', error_description: 'client_id mismatch' }, 400);
        }

        if (redirect_uri && authCode.redirectUri !== redirect_uri) {
          return jsonResponse({ error: 'invalid_grant', error_description: 'redirect_uri mismatch' }, 400);
        }

        const verifierHash = base64urlEncode(await sha256(code_verifier));
        if (verifierHash !== authCode.codeChallenge) {
          return jsonResponse({ error: 'invalid_grant', error_description: 'PKCE verification failed' }, 400);
        }

        if (!env.OAUTH_JWT_SECRET) {
          return jsonResponse({ error: 'server_error', error_description: 'JWT secret not configured' }, 500);
        }

        const now = Math.floor(Date.now() / 1000);
        const accessToken = await signJWT({
          iss: origin,
          sub: 'mcp-user',
          aud: authCode.resource || origin,
          scope: authCode.scope || 'mcp',
          iat: now,
          exp: now + ACCESS_TOKEN_TTL,
          jti: randomHex(16)
        }, env.OAUTH_JWT_SECRET);

        return jsonResponse({
          access_token: accessToken,
          token_type: 'Bearer',
          expires_in: ACCESS_TOKEN_TTL,
          scope: authCode.scope || 'mcp'
        });
      } catch (err) {
        return jsonResponse({ error: 'server_error', error_description: err.message }, 500);
      }
    }

    // ── OAuth Dynamic Client Registration ──

    if (url.pathname === '/oauth/register' && request.method === 'OPTIONS') {
      return corsPreflight();
    }

    if (url.pathname === '/oauth/register' && request.method === 'POST') {
      try {
        if (!env.OAUTH_KV) {
          return jsonResponse({ error: 'server_error', error_description: 'OAuth KV not configured' }, 500);
        }

        const body = await request.json();
        const redirect_uris = body.redirect_uris;
        if (!Array.isArray(redirect_uris) || redirect_uris.length === 0) {
          return jsonResponse({ error: 'invalid_client_metadata', error_description: 'redirect_uris is required' }, 400);
        }

        const tokenEndpointAuthMethod = body.token_endpoint_auth_method === 'client_secret_post'
          ? 'client_secret_post'
          : 'none';

        const clientId = randomHex(16);
        const clientSecret = tokenEndpointAuthMethod === 'none' ? null : randomHex(32);

        const client = {
          client_id: clientId,
          client_secret: clientSecret,
          client_name: body.client_name || 'Unknown Client',
          redirect_uris,
          grant_types: body.grant_types || ['authorization_code'],
          response_types: body.response_types || ['code'],
          scope: body.scope || 'mcp',
          token_endpoint_auth_method: tokenEndpointAuthMethod,
          created_at: Math.floor(Date.now() / 1000)
        };

        await putKvJson(env, prefix + ':client:' + clientId, client);

        return jsonResponse({
          ...client,
          client_id_issued_at: client.created_at,
          client_secret_expires_at: 0
        }, 201);
      } catch {
        return jsonResponse({ error: 'invalid_request', error_description: 'Invalid JSON body' }, 400);
      }
    }

    // ── MCP Request Handling (JWT validation + proxy) ──

    const authHeader = request.headers.get('Authorization');
    if (authHeader && authHeader.startsWith('Bearer ') && env.OAUTH_JWT_SECRET) {
      const token = authHeader.slice(7);
      const claims = await verifyJWT(token, env.OAUTH_JWT_SECRET, origin);

      if (claims) {
        const headers = new Headers(request.headers);
        if (env.BEARER_TOKEN) {
          headers.set('Authorization', 'Bearer ' + env.BEARER_TOKEN);
        }
        const authenticatedRequest = new Request(request.url, {
          method: request.method,
          headers,
          body: request.body,
          duplex: 'half'
        });
        return OriginalWorker.fetch(authenticatedRequest, env, ctx);
      }
    }

    return new Response(
      JSON.stringify({ error: 'Unauthorized' }),
      {
        status: 401,
        headers: {
          'content-type': 'application/json',
          'WWW-Authenticate':
            'Bearer resource_metadata="' + origin + '/.well-known/oauth-protected-resource"',
        },
      }
    );
  }
};
`.trim();
}
