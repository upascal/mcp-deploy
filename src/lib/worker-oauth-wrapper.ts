/**
 * Generates an OAuth wrapper module that sits in front of MCP worker bundles.
 *
 * At deploy time, we upload TWO modules to Cloudflare:
 *   1. `original.mjs` - The actual MCP worker code from the GitHub release
 *   2. `index.mjs`    - This generated wrapper (the main_module entry point)
 *
 * The wrapper:
 *   - Serves `/.well-known/oauth-protected-resource` (RFC 9728) so MCP clients
 *     can discover the OAuth authorization server.
 *   - Validates OAuth JWT access tokens (HMAC-SHA256) issued by mcp-deploy.
 *   - Falls back to the inner worker's existing bearer-token auth for backward compat.
 *   - On 401/403 from the inner worker, adds WWW-Authenticate header with
 *     resource_metadata link for MCP OAuth discovery.
 *   - Re-exports Durable Object classes from the original worker.
 */

/**
 * Generate the OAuth wrapper module code.
 *
 * @param durableObjectClassName - The DO class to re-export (e.g., "ZoteroMCP")
 * @param issuerUrl - The mcp-deploy instance URL (authorization server)
 */
export function generateOAuthWrapper(
  durableObjectClassName: string,
  issuerUrl: string
): string {
  // The wrapper is generated as a string because it runs in Cloudflare Workers,
  // not in Node.js. It uses only Web Crypto APIs.
  return `
// ─── OAuth Wrapper for MCP Worker ───
// Auto-generated by mcp-deploy. Do not edit.

import OriginalWorker from './original.mjs';
export { ${durableObjectClassName} } from './original.mjs';

// Base64url decode (Web Crypto compatible)
function base64urlDecode(str) {
  str = str.replace(/-/g, '+').replace(/_/g, '/');
  while (str.length % 4) str += '=';
  const binary = atob(str);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes;
}

// Verify HMAC-SHA256 JWT using Web Crypto
async function verifyJWT(token, secret, expectedAudience) {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const [headerB64, payloadB64, signatureB64] = parts;

    // Import the HMAC key
    const keyData = new TextEncoder().encode(secret);
    const key = await crypto.subtle.importKey(
      'raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['verify']
    );

    // Verify the signature
    const data = new TextEncoder().encode(headerB64 + '.' + payloadB64);
    const signature = base64urlDecode(signatureB64);
    const valid = await crypto.subtle.verify('HMAC', key, signature, data);
    if (!valid) return null;

    // Decode and validate claims
    const payload = JSON.parse(atob(payloadB64.replace(/-/g, '+').replace(/_/g, '/')));
    const now = Math.floor(Date.now() / 1000);

    if (payload.exp && payload.exp < now) return null;
    if (expectedAudience && payload.aud && payload.aud !== expectedAudience) return null;

    return payload;
  } catch {
    return null;
  }
}

const ISSUER_URL = ${JSON.stringify(issuerUrl)};

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // 1. Serve OAuth Protected Resource Metadata (RFC 9728)
    if (url.pathname === '/.well-known/oauth-protected-resource') {
      return new Response(JSON.stringify({
        resource: url.origin,
        authorization_servers: [ISSUER_URL],
        bearer_methods_supported: ['header']
      }), {
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
          'Cache-Control': 'public, max-age=3600'
        }
      });
    }

    // 2. Check for OAuth JWT in Authorization header
    const authHeader = request.headers.get('Authorization');
    if (authHeader && authHeader.startsWith('Bearer ') && env.OAUTH_JWT_SECRET) {
      const token = authHeader.slice(7);
      const claims = await verifyJWT(token, env.OAUTH_JWT_SECRET, url.origin);

      if (claims) {
        // Valid OAuth JWT - pass request to inner worker with the static bearer token
        // so the inner worker's existing auth check passes.
        const headers = new Headers(request.headers);
        if (env.BEARER_TOKEN) {
          headers.set('Authorization', 'Bearer ' + env.BEARER_TOKEN);
        }
        const authenticatedRequest = new Request(request.url, {
          method: request.method,
          headers,
          body: request.body,
          duplex: 'half'
        });
        return OriginalWorker.fetch(authenticatedRequest, env, ctx);
      }
    }

    // 3. Pass through to inner worker (handles static bearer token and path-based auth)
    const response = await OriginalWorker.fetch(request, env, ctx);

    // 4. If inner worker returned 401 or 403, add WWW-Authenticate header
    //    so MCP clients can discover the OAuth flow.
    if ((response.status === 401 || response.status === 403) && env.OAUTH_JWT_SECRET) {
      const newHeaders = new Headers(response.headers);
      newHeaders.set(
        'WWW-Authenticate',
        'Bearer resource_metadata="' + url.origin + '/.well-known/oauth-protected-resource"'
      );
      return new Response(response.body, {
        status: 401,
        headers: newHeaders
      });
    }

    return response;
  }
};
`.trim();
}
